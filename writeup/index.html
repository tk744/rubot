<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="style.css">
  <title> Rubot </title>
</head>
<body>
      <img src="cube.jpg" alt="Headshot" width = "300" height = "150" class="cube">

<h1> Rubot </h1>
<h3 id="authors" > Alexander Drazic(ard226), Myles Cherebin(mac497), Tushar Khan(tak62) </h3>
<h2>Introduction</h2>
  <p> Almost everybody has used a rubik's cube puzzle before, whether they are picking
  up the cube for the first time, looking up the solution algorithms, or playing
  around with a different iteration. Many different kinds of rubik's puzzles have
  come out over the years, such as the Rubik's Cube Pyramid and the 2-by-2 cube
  Rubik's Cube. The most common of these puzzles is the original 3-by-3 Rubik's Cube.
  For our final project, we made a Rubik's Cube solver that can guide people how to solve their
  Rubik's Cube after they have been scrambled. </p>
<h2>High Level Design </h2>
  <p> In order to operate Rubot, a user must take a solved cube first and scramble it with a set of moves.
     The user then sends the move set to the PIC32 using a python GUI for the cube to be solved. The PIC32 
     then proceeds to solve the cube and generates a solution move set. Finally, the solution moveset is 
     displayed on a TFT screen that is attached to the PIC32. The solution moveset displays one move at a 
     time and the user can go to the next or previous move in the moveset by using buttons on the GUI.
  </p>
  <center><img src = "high_level_diagram.png" style=" width:80%; height:80%;"></center>
<h2> Hardware </h2>
  <p> Our project was mostly implemented with software. Visuals on the TFT display
    show the user the state of the solving algorithm and what moves to execute.
 </p>
<h2> Software </h2>
  <p> The software is broken down into 3 modules: <code>solver</code>, <code>gui</code>, and <code>pic32</code>. The <code>solver</code> module implements the Rubik's cube solving algorithm and associated state, the <code>gui</code> module implements the Python GUI to communicate serially with the microcontroller, and the <code>pic32</code> module implements hardware-specific code including for the TFT display. Each module was designed, developed, and tested independently. </p>
  <h3><code>solver</code> Module</h3>
    <h4>Cube State</h4>
      <p>
        The 26 minature cubes that makes up a full Rubik's cube is called a <i>cubie</i>. Every Rubik's cube has 12 edge cubies that can be in one of two orientations, and 8 corner cubies that can be in one of three orientations. Since the 6 face cubies are not affected by face rotations, we only encode the edge and corner cubies in our cube representation. We enocde edge cubies using 5 bits (first bit encodes orientation, next four bits encode permutation), and corner cubies also using 5 bits (first two bits encode orientation, next three bits encode permutation). Then we encode a cube state with two 64-bit integers, the first integer encoding the 12 edge cubies sequentially, the second integer encoding the 8 corner cubies sequentially. To read the value of an arbitrary cubie, we simply select the appropriate integer and read the orientation and permutation at the index of that cubie.
      </p><p>
        Moves are what cause transformations between cube states. Each move must specify the face of rotation; and also specify whether the rotation is a quarter-turn clockwise, quarter-turn counter-clockwise, or a half-turn. We encode the face of rotation for a move as a one-hot encoded 6-bit integer. We encode the rotation value as a one-hot encoded 2-bit integer where the rotation is quarter-turn clockwise by default, one bit flag makes the rotation counter-clockwise, and the other bit flag makes the rotation a half-turn. Then we encode a single move as an 8-bit integer where the first 2 bits encode information about the rotation value, and the last 6 bits encode information about the face of rotation.
      </p><p>
        Finally we implemented a transformation function which takes a cube state and a move, and returns the new cube state obtained by applying the move to the original cube state. Decoding moves is relatively simple given their encoding. Each move requires shifting the permutations of four edges and four corners, which is also relatively simple. The tricky part is updating their orientations.
      </p>
    <h4>Cube Solver</h4>
      <p>
        The Rubik's cube solving algorithm we chose to implement is an improved version of Thistletwaite's algorithm. Thistletwaite's original algorithm is guaranteed to find a solution within 52 moves, while our improved one can find a solution within 46 moves. Thistletwaite's algorithm is an improvement over brute-force search algorithms which would never terminate in such an overwhelmingly large state space, and over ineffecient human algorithms that freqently break properties that are built up in previous stages while progressing towards the next stage. It is a relatively complicated algorithm that is only practical for computer solving and not for humans to memorize.
      </p><p>
        Thistletwaite's algorithm is better explained by rudimentary group theory. It divides the space of cube states into 4 nested groups, where a group is defined by a set of moves and contains the set of cube states that can be solved using that set of moves. The algorithm progresses in 4 phases, where phase <code>i</code> aims to bring a cube from group <code>G(i-1)</code> to group <code>Gi</code> only using the set of moves in group <code>G(i-1)</code>. Restricting the set of moves that can be applied to the cubes in a group fixes properties of the cubes that cannot be broken once that group is reached. The four groups of Thistletwaite's algorithm and the fixed properties of their cubes is given below:
        <table style="width:100%">
          <tr>
            <th>Group</th>
            <th>Number of States</th>
            <th>Fixed Properties</th>
          </tr>
          <tr>
            <td>G0 = {F, B, L, R, U, D}</td>
            <td>2048</td>
            <td>None.</td>
          </tr>
          <tr>
            <td>G1 = {F, B, L, R, U2, D2}</td>
            <td>1082565</td>
            <td>Edge orientations.</td>
          </tr>
          <tr>
            <td>G2 = {F, B, L2, R2, U2, D2}</td>
            <td>352800</td>
            <td>Corner orientations, edges in middle slice in correct slice.</td>
          </tr>
          <tr>
            <td>G3 = {F2, B2, L2, R2, U2, D2}</td>
            <td>663552</td>
            <td>Edges in correct slices, corners in correct tetrad pairs.</td>
          </tr>
          <tr>
            <td>G4 = I = {}</td>
            <td>1</td>
            <td>Solved cube.</td>
          </tr>
        </table> 
      </p><p>
        We implemented Thistletwaite' algorithm as an IDDFS search 

      

      </p>

    <h4>Testing</h4>
      <p>
        We initially chose to represent cubes as a 54-element array, which maps a square on the cube to its current color.
      </p>

  <h3><code>gui</code> Module</h3>
  <h4>Python Serial GUI</h4>
    <center><img src="final_gui_pic.JPG"></center>
    <p> The user interface was designed with ease of use in mind for the user. With only four buttons 
      and one input field, this goal was achieved. To use the GUI, a user types in a defined set of moves 
      that would be explained in a user manual. These moves are: F, R, U, B, L, D, F’, R’, U’, B’, L’, D’, 
      F2, R2, U2, B2, L2, D2. This nomenclature is very common among the rubik’s cube community. A user 
      scrambles their cube and writes down each move they’ve chosen to make and inputs this move into the 
      “Move Input” input field. The user clicks solve and then the solving moves are flashed to the TFT 
      screen of the PIC32. A user can then step forwards and backwards through the solving moves using 
      the “TFT Controls” buttons.
      <br><br>
      The Python interface also must parse the user input in the background before sending it to the PIC
       for processing. When the user clicks “Solve”, the GUI takes the user’s input and turns each move into
        an element in an array. Then, each move in the array is converted into an 8-bit binary representation. 
        Finally, the array is encoded and a header, the number of moves, and a terminating character is added. 
        This encoded “package” is then sent to the PIC32 via the UART serial connection.
      <br><br>
      The next, “>”, and previous, “<”, move buttons work in the same way as the “Solve” button except only
       the header and terminating characters are needed because button differentiation is done with the header characters.

    </p>
    <h3><code>pic32</code> Module</h3>
    <h4>TFT Display</h4>
    <p> As they are going through the solution steps, the user is shown what number
      step they are on, as well as the next move they should do. In addition to this,
      we also wanted to give them a reference for what their cube should look like after each move.
      The graphic is made up of two images, each showing three sides of the cube.
      The locations of the faces on the images are based on how the cube appears
      when it is looked at from the orientation of the images.
    </p>
    <img src="pre_color.jpg" width=800>

    <p> The representation of each face includes two opposite edges and nine unsigned
      short color values named color0 through color8. These values determine what
      color a given square on a face is drawn. The color of the square in the 0
      position is color0 and the color of the square in the 8 position is color8.
      The following image shows how the positions of squares on a face are determined.
    </p>
    <img src="face_representation.JPG">
    <p> In order to color a face, the coordinates of the face and the square position
      are used to determine where the color should go. Parallel lines of
       the given color are drawn across the square to give the appearance of a
       full square of color.
    </p>
<h2> Results </h2>
  <p> </p>
<h2> Conclusions</h2>
  <p> </p>
<h2>Appendix</h2>
<h3>Appendix A: Inclusions</h3>
<p> This group approves of this report for inclusion on the course website. </p>
<p> This group approves the video for inclusion on the course youtube channel.</p>
<h3>Appendix B: Code Listing</h3>
<h3>Appendix C: Schematics</h3>
  <p> Board Schematic:</p>
  <img src="board_schematic.JPG" width = "850" height = "800">
<h3>Appendix D: Cost Details</h3>
<p> We did not use any additional parts except what was provided to us. </p>
<div class="unorderlist">
<ul>
  <li> Big Board $10 </li>
  <li> PIC32MX250F128B $5 </li>
  <li> I/O expander $5 </li>
  <li> TFT LCD $10  </li>
  <li> Jumper Cables $.30 </li>
  <li> USB to Serial Cable $9.95  </li>
</ul>
</div>
<p>Total: $40.25 </p>
<h3>Appendix E: Work Breakdown</h3>
<h3>Appendix F: References</h3>

</body>
</html>
